\documentclass[11pt]{article}

\usepackage{fullpage}
\usepackage{tikz}
\usepackage{listings}
\usetikzlibrary{shapes,arrows}

\begin{document}

\title{Group 6 Final Report}
\author{Chan Chun ckc116, Cheung Ka klc116, Mang Hao hxm16, Cheuk Ki kfc216}

\maketitle

\section{Implementation of the assembler}

 
After careful discussion, we have decided to implement the assembler using two passes over the source code as specified in the spec, which then leads to the following structure:\newline\newline
Structures:
Linkedlist,
BST,
Line tokens,
Instructions
\newline
Tokenizer
(tokenizer.c)
(tokenizer.h)\newline
Table
(table.c)
(ADT{\_}BST.c)
(ADT{\_}linkedlist.c)\newline
I/O
(assemble.c)\newline
Assembing instructions
(ass{\_}branch.c)
(ass{\_}dp.c)
(ass{\_}multiply.c)
(ass{\_}sdt.c)\newline
Two-pass assembly
(firstpass.c)
(secondpass.c)\newline
Utility function
(ass{\_}util.c)\newline
Main
(assemble.c)

\subsection{Reading the source file}
\begin{itemize}  
\item Use the function sourcefilereader()  in ass{\_}util.c

\item Store the number of lines for further uses 

\item Store the content of the source file in an array of char*[100] for further use, assuming that the number of lines will not exceed 100  

\end{itemize}





\subsection{Parsing the file}
\begin{itemize}  
\item Use the function filetotokens() in tokenizer.c
\item Each line is stored in a struct showed beside
\item Type including label and operands, line{\_}tokens with type operands will have the opcode enabled vice versa
\end{itemize}


\subsection{First pass}
Extracts all lines with the type LABEL and creates a table, using a LINKEDLIST structure implemented by us, each element is stored with the name of the label and the index (the relative position of the label in the instructions)
\subsection{Calling appropriate functions depending on the opcode (Second Pass)}
By using an if else branch, separate different LINE{\_}TOKENS according to their opcode (e.g. MOV, STR, LDR, etc..), we call the appropriate functions and providing other information to the functions if required. These functions called are expected to return a type of following struct: 

\begin{center}
\begin{tabular}{|c|c|}
\hline
\begin{lstlisting}[language = C]
typedef struct {
   char type[20];
   union {
	DATAPROCESSING_INSTR *dp; 
	MULTIPLY_INSTR *mp;
	SIN_DATA_TRAN_INSTR *sdt;
	BRANCH_INSTR *br;
   } instr;  
} INSTRUCTION;
\end{lstlisting} &

\begin{lstlisting}[language = C]
typedef struct br {
   u32 INSTRUCTION;
   char OPCODE[4];
   u32 COND: 4;
   u32 OFFSET;
} BRANCH_INSTR;
\end{lstlisting}\\
\hline

\end{tabular}
\end{center}

\subsubsection{Data Processing}
The only part worth mentioning is the part identifying different types of operand2 , this is achieved by using several if else branches, which includes identifying the first character of the operand to be a '\#' , to seperate shift registers and expressions, and to determine whether there is a shift or not based on the number of operands in LINE{\_}TOKEN. 

\subsubsection{Branch}
\begin{itemize}  
\item First, it looks up the address of the label by looking up the linked list, calculating the offset by considering the current address and the pipeline principle.

\item It then transforms the offset, which is of type INT into two's complement using a helper function transformnum(), the two's complement is stored as a u32 (unsigned 32 bit).
\end{itemize}




\subsubsection{Single Data Transfer}
\begin{itemize}  
\item Calculates the offset with immediate value. Shifts of the registers are approximately the same as Data Processing, but with a few more exceptions.

\item Instead of using if else branch to identify different types of $<address>$, a helper function parseExpressioninrect() is used. It identifies different types by calculating the number of expressions in the square bracket and the number of expressions that are not.
\end{itemize}

\subsubsection{Multiply}
This part is pretty straight forward, we just have to fit in different registers to the appropriate fields in INSTRUCTION.

\subsection{Assemble the INSTRUCTION into binary (Second Pass)}
This is achieved by simply shifting the instruction to the appropriate position. A little remark is that we chose to use $|=$ rather than += as it will be easier for debugging. If we use += and the field (e.g. DEST in DATAPROCESSING{\_}INSTR) is longer than its expected length, it will be difficult to debug, especially when it is a binary code.

\section{Description of our extension - Simon}
Our extension is to implement an early version of the game Simon -- a simple game which trains the memorisation of children. In our game, there are 4 buttons which corresponds to the 4 LEDs of different colours for the player to press on. In each round a sequence of LEDs would light up, the player will then have to repeat the sequence by pressing the buttons associated to each LED. The next element of the sequence is randomly generated by a random generator and will be stored for use in the entire game. The game is made harder and harder by adding one more element to the sequence in each consecutive round. In our game, there are two levels which consists of sixteen rounds each. The second level is more difficult as we reduce the delay between the lights on of the LEDs in a sequence. Below is the layout of the game:
\begin{figure}[h!]
\centering
\includegraphics[width = 0.75\linewidth]{TOP1.jpg}
\caption{Layout of the game}
\label{fig::layout}
\end{figure}

We chose to use C to program the game $(./arm11{\_}06/extension/simon.c)$ and library bcm2835 to access the GPIO pins of Raspberry Pi (Revision 2). Each pin corresponds to one LED or button. As figure \ref{fig::layout} shows, there is a binary counter to calculate the score of the player, three states indicating LEDs (Yellow, Green and Red)to represent the end of a sequence, correct input and wrong input respectively. Below is the flowchart of the game.

%Flow Chart for games
% Define block styles
\tikzstyle{decision} = [diamond, draw, fill=blue!20,
   text width=4.5em, text badly centered, node distance=3cm, inner sep=0pt]
\tikzstyle{block} = [rectangle, draw, fill=blue!10,
   text width=15em, text centered, rounded corners, minimum height=4em]
\tikzstyle{line} = [draw, -latex']
\tikzstyle{blocks} = [rectangle, draw, fill=blue!10,
   text width=5em, text centered, rounded corners, minimum height=4em]
 
 \begin{tikzpicture}[node distance = 2cm, auto]
 
   % Place nodes
   \node [block] (start) {Start The game at level 0};
   \node [block, below of=start] (random) {A random sequence is generated followed by a blink of the yellow LED on the top right corner};
   \node [decision, below of=random] (input) {Correct Input?};
   \node [block, right of=input, node distance=5cm] (correct) {Correct sequence , the green LED on the top right corner will blink to indicate correctness};
   \node [block, left of=input, node distance=5cm] (wrong) {The red LED on the top right corner will blink to indicate a wrong input};
   \node [block, below of=correct, node distance=2cm] (counter) {The binary counter for the score will increment by 1 and will go on to the next level whenever 16 is scored };
   \node [block, below of=counter, node distance=2cm] (win) {Once the player finished level 2, the player win the game};
   \node [blocks, right of=random, node distance=8.5cm] (wait) {Prints winning pattern};
  
   % Draw edges
   \path [line] (start) -- (random);
   \path [line] (random) -- (input);
   \path [line] (input) -| node [near start] {no} (wrong);
   \path [line] (input) -- node  {yes} (correct);
   \path [line] (correct) -- (counter);
   \path [line] (correct) |- node[near start]{wait for next sequence}(random);
   \path [line] (wrong) |- node[near start]{restart}(start);
   \path [line] (counter) -- (win);
   \path [line] (win) -| (wait);
   \path [line] (wait) |- node[near start]{restart}(start);
 
\end{tikzpicture}
\begin{figure}[h!]
\caption{Flow chart of the game}
\end{figure}


\section{Design and the associated challenges of Simon}
During the extension implementation, there are two main problems.
\begin{itemize}
\item Hardware problems, as most of our team members are not familiar with electronics, we are confused on connecting wires on the breadboard and often encounter bugs caused by hardware problems (The LED is not blinking and no valid input is taken because of a wrong circuit design)
\item Software problems, as we are using the library bcm2835, many of its functions are new to us and sometimes we may misunderstood the function.
\end{itemize}

\section{Testing for our implementation on Simon}
While debugging, we have designed a few general test cases and test by inputing the variables manually. Some group mates would carry on implementing other functions while others continue testing the function by designing more specific edge cases.
The library bcm2835.h is used to enable access to different pins. Before using the library, we have tested the library with some simple functions to make sure that the library works and we understand the properties of functions from the library.
It is also important for us to test each hardware component. We have to make sure that they are all working properly before the final tests. \\After making sure that each function works, we move on to a larger scale of testing. Simon is not very complicated and the gameplay is rather straightforward, therefore we have played the game for a number of times in order to make sure that the game works.\newline 
Later on, we have discussed and designed a few cases for testing, which includes intentionally pressing the wrong button at the wrong time. 


\section{Group Reflection}
In the beginning of the project, we mainly work together as a group in the lab with some team members programming while others doign research. Working in this way helps us resolve any problem very quickly as we can support each other face-to-face. Also, we found this beneficial because we are not familiar with C at the very beginning and lots of help is needed. However, working together in the lab means that we will have to work on each part of the project one at a time, which slows down the progress. Since we all know more about C in the middle of the project and require less support from each other, we changed our approach when working on the assembler. This is the moment when we divide work amongst all members to allow work being done individually, each member is responsible for several branches on git which we later merge them into a single file. The efficiency has since then increased a lot. If we were given the chance to start the project again, we would have started the work allocation straight from the start of the project so that members can do their own individual research back at home and discuss about problems and difficulties when we are having our team meeting. In conclusion, we are satisfied on our work allocation and team communication and are looking forward to collaborate in the future.

\section{Individual Reflection}
\textbf{Hao, Mang (hxm16):}
\\ Across the project, I found it satisfying and demanding. My WebPA feedback has proven that I am active member of the team and making great contributions throughout the whole project.
\\When I first started off, I felt very uncomfortable in the team  as I don't know well about the strength of my teammates, so it is hard to coordinate the team to work efficiently in the beginning. Also, as we are unfamiliar with Git and C programming, many of our works are having conflicts. So, in the first two week, we are behind schedule. I feel our group time management could have been improved if we have a better communication in the team. It will save a lot of time for explain the specification to the teammate who are behind progress.
\\In the future projects, I will maintain the skills of setting deadlines and milestones at the beginning of the project. It have been proven to be a effective ways to improve our time management in the project and to 
\\
\\
\textbf{Ka, Cheung (klc116):}
\\I took up the role as the ‘coordinator’ in this project. After we have discussed the work allocation, I kept note of each group mates work and how will their code be used in one another’s programs. If a group mate had query on how the parameters will be passed to him in the code or wanted a general utility function to be implemented, they would discuss with me and I would explain and help them implement the function to the master branch so they would be able to use it in their own branch. Through this project I realize the importance of a coordinator as without one the final result will be less than the sum of its parts. Conflicts appears when groupmates were not sure what others were working on so even though both code works when tested separately, errors occur when they are combined together, and that is when a coordinator and iron out the conflicts and help debugging the combined code. Being a coordinator is certainly demanding, but getting to learn the whole structure thoroughly proved to be a valuable experience for me. I would certainly try out this role in future projects.  
\\
\\
\textbf{Ki, Cheuk (kfc216):}
\\Throughout the project, i realise that debugging is a really important process, and difficult as well if good practises are not implemented. I learnt that it is usually a beneficial  to use the function printf() and state which part the program is running, and also print out the partial processed variables so that i can check whether the code is doing what we want it to do.
\\On the other hand, it is also really important to implement a set of detailed test cases, i realised that missing edge cases may cause a huge problem later on. For example, we didn’t consider some special cases when debugging assembler. Then later on it turn out to be a problem when we are implementing the raspberry pi and the extension. It cost a lot of time for us to solve this kinds of problem. 
\\This project also teach me that communication with teammate are in fact, more important than I have thought. For example, even we have allocated our work while implementing assembler, I should have discuss with my teammates more frequently so that I will have a better understanding of how each part of the program interact with each other. Many bugs are caused by these poor understandings of each other's work.
\\
\\
\textbf{Chun, Chan (ckc116):}
\\
\\
I found the project satisfying and fun to do. The first part of the project is quite hard to go through as we are not familiar with Git and C but as soon as we are trained up, our team’s efficiency has increased a lot.
\\In a technical sense, I found debugging both the most challenging and rewarding part. In the beginning of the year, I once thought that debugging is just something extra and unimportant, but it turns out to be one of the most essential element to a programmer. 
\\Apart from debugging, I also learnt a lot in designing a program. Compared with doing the Lexis tests, where programs are designed already and our main task is just to implement several methods, this project is built completely from scratch. Whenever we are stuck or unfamiliar with a certain part of the program, we always do our own research or ask teammates for help. This makes the exercise more realistic because later when we get to work it will be of the exact same situation -- a majority of projects are started from scratch.
\\In terms of team working, I am not so confident with our communication at the very beginning but as the project goes on we are collaborating much better as we start to know each other’s strength and mutual trust is built. So in fact I am satisfied to be in the team and contribute.





\end{document}
